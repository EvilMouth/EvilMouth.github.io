{"componentChunkName":"component---src-templates-blog-post-js","path":"/android-incremental-update-diff-and-patch/","result":{"data":{"site":{"siteMetadata":{"title":"Evil Mouth","author":{"name":"Evil Mouth"}}},"markdownRemark":{"id":"3dd8bf48-fe51-51b3-898b-bac6dfd99526","excerpt":"调研 Android 差分包过程记录 前测 目前市场差分方案有 bsdiff - 最常见的差分方案，例如国内应用市场的增量更新 archive-patcher - 谷歌推出的基于 bsdiff 的优化方案，使差分包更小 apkdiff - Github 开源的项目，基于 archive-patcher…","html":"<p>调研 Android 差分包过程记录</p>\n<!-- More -->\n<h2>前测</h2>\n<p>目前市场差分方案有</p>\n<ul>\n<li>bsdiff - 最常见的差分方案，例如国内应用市场的增量更新</li>\n<li>archive-patcher - 谷歌推出的基于 bsdiff 的优化方案，使差分包更小</li>\n<li>apkdiff - Github 开源的项目，基于 archive-patcher 思想</li>\n<li>xdelta - 市面使用较少，但比 bsdiff 性能佳</li>\n</ul>\n<p>以两个大约 38M 的 apk 作为例子</p>\n<ul>\n<li>bsdiff：差分包 10M</li>\n<li>archive-patcher：得基于两个 zlib 包，所以得先将两个 apk 进行 zlib 压缩（体积可能会变大），但是差分效果佳，差分包 400k</li>\n<li>apkdiff：使用 lzma 压缩，差分包 300k，但是会导致合成包 md5 不一致，也可以先将 apk 进行 zlib 后再使用 apkdiff，则 md5 相同</li>\n<li>xdelta：差分包 10M，但是差分和合成的速度和内存优于 bsdiff</li>\n</ul>\n<h2>分析</h2>\n<h3>bsdiff</h3>\n<ul>\n<li>比较常见的差异算法，不过因为较通用，所以没有考虑 apk 实际上是一个 zip 压缩包的情况，直接将 apk 当成文件去进行差异对比，所以产生的差异包较大</li>\n<li>patch 时需要用到 O(m+n)的内存</li>\n</ul>\n<h3>archive-patcher</h3>\n<ul>\n<li>严格基于 zlib，apk 需要使用 zlib 重新压缩</li>\n<li>差分和合成依旧使用 bsdiff</li>\n<li>之所以差分包大小比 bsdiff 小是因为先解压后再 diff，比直接 diff 更容易描述差异</li>\n<li>如果 apk 没有 zlib，将直接 bsdiff（差异包大小会与 bsdiff 一样大）</li>\n<li>将 apk 解压后进行 file-to-file 的差异对比，得到差异包</li>\n<li>patch 阶段将差异包压缩回 apk（使用了 zlib）得到最终 apk 包</li>\n</ul>\n<h3>apkdiff</h3>\n<ul>\n<li>合成后只保证逻辑相同，不保证二进制相同，这一点可以通过 zlib 压缩后解决（因为解压和压缩用了相同的编码）</li>\n<li>差分和合成使用 hdiff，性能优于 bsdiff</li>\n<li>核心原理是将 apk 解压后进行差异对比，改动越小，差异包越小，比较符合增量更新意义</li>\n<li>比 archive-patcher 暴力的是 diff 阶段直接解压然后差异对比，patch 阶段直接 zlib 压缩回 apk 包，所以会导致二进制不相同</li>\n<li>所以提供了 ApkNormalized 预处理 apk 包</li>\n<li>需要注意的是，ApkNormalized 重新压缩 apk 包后导致的二进制不相同会影响 v2 和 v3 的签名（v1 不影响是 v1 不严格要求），所以如果项目使用 v2 或 v3 的签名方式需要在 ApkNormalized 后进行重签名</li>\n</ul>\n<h3>xdelta</h3>\n<ul>\n<li>性能比 bsdiff 好以及稳定，但差异包大小与 bsdiff 差不多甚至更大一些</li>\n<li>没有继续研究</li>\n</ul>\n<h2>接入成本</h2>\n<ul>\n<li>以 armeabi-v7a 为例</li>\n<li>jni 以 so 实际大小</li>\n<li>java 以 jar 实际大小</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>bsdiff</th>\n<th>archive-patcher</th>\n<th>apkdiff</th>\n<th>xdelta</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>接入方式</td>\n<td>jni</td>\n<td>java</td>\n<td>jni</td>\n<td>jni</td>\n</tr>\n<tr>\n<td>接入大小</td>\n<td>322KB</td>\n<td>190KB</td>\n<td>137KB</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2>diff 对比</h2>\n<ul>\n<li>由于 diff 过程属于预处理，一般放在服务器，所以只做时间对比</li>\n<li>设备信息如下</li>\n<li>\n<ul>\n<li>macOs Catalina 10.15.4</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>3.1GHz i5 16GB</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>bsdiff</th>\n<th>archive-patcher</th>\n<th>apkdiff</th>\n<th>xdelta</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>差分包生成时间</td>\n<td>42s 左右</td>\n<td>24s 左右</td>\n<td>10s 左右</td>\n<td>4s 左右</td>\n</tr>\n</tbody>\n</table>\n<h2>patch 对比</h2>\n<ul>\n<li>测试机信息如下</li>\n<li>\n<ul>\n<li>华为 LRA-AL00 Android9 API28</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>运行内存 8.0GB</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>屏幕 2400 x 1080</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>手机存储 128 GB</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>CPU 架构 arm64-v8a</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>bsdiff</th>\n<th>archive-patcher</th>\n<th>apkdiff</th>\n<th>xdelta</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>差分包大小</td>\n<td>10.6M</td>\n<td>448k</td>\n<td>304k</td>\n<td></td>\n</tr>\n<tr>\n<td>cpu 占用</td>\n<td>17%-24%</td>\n<td>17%-22%</td>\n<td>17%-23%</td>\n<td></td>\n</tr>\n<tr>\n<td>内存占用</td>\n<td>86M</td>\n<td>80M</td>\n<td>6M</td>\n<td></td>\n</tr>\n<tr>\n<td>合成时间</td>\n<td>5104ms</td>\n<td>3841ms</td>\n<td>3140ms</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>实际做了挺多次对比，结果大致相同，所以不放出</p>\n</blockquote>\n<h2>patch 时多渠道因素</h2>\n<h3>问题</h3>\n<p>前因</p>\n<ul>\n<li>差异包只会打一个，以官方渠道包的新旧两个 apk 进行差异对比得到的差异包</li>\n<li>线上会存在多种渠道包，目前渠道包以两种形式存在</li>\n<li>1、ng-plugin 生成的渠道包（在 Zip Comment Central Directory 区域实现）</li>\n<li>2、Android Manifest 中 meta-data（部分渠道包还会更改应用名）</li>\n</ul>\n<p>后果</p>\n<ul>\n<li>由于 diff&#x26;patch 要求 oldApk 完全一致（渠道包因为 Android Manifest 文件不同已经破坏一致），线上用户使用本地渠道包进行 patch 违反这一条约，所以 patch 会失败</li>\n</ul>\n<h3>如何解决 Zip Comment Central Directory</h3>\n<p>ng-plugin 方案是在 Central Directory 的注释部分插入渠道信息，不会到 apk 造成破坏，可以正常安装，但注释也是数据的一部分，也会参与 diff，所以会造成渠道包和原始包不一致导致无法 patch</p>\n<ul>\n<li>通过先抹除渠道信息再 patch</li>\n<li>如果需要保留原渠道信息，还可以再进行渠道的插入</li>\n</ul>\n<h3>如何解决 Android Manifest</h3>\n<p>思路 1</p>\n<ul>\n<li>用户在拿到 patch 包后</li>\n<li>利用本地渠道包还原 oldApk，再以 oldApk 去进行 patch 得到 newApk</li>\n<li>难点 1、还原 oldApk 过程需要与 Jenkins 打包流程一致才能保证 100%还原</li>\n<li>不足点 1、还原所需时间=打包所需时间，用户端消耗不起</li>\n</ul>\n<p>思路 2</p>\n<ul>\n<li>diff 阶段排除 Android Manifest 文件的差异对比</li>\n<li>下发 patch 包同时下发新的 Android Manifest 文件</li>\n<li>patch 阶段将新 Android Manifest 文件 copy 进去后再压缩回 apk 文件</li>\n<li>难点 1、保证生成的 newApk 与正常流程的 newApk 一致</li>\n</ul>\n<h2>Demo</h2>\n<p><a href=\"https://github.com/izyhang/DiffPatchRecord\">https://github.com/izyhang/DiffPatchRecord</a></p>","frontmatter":{"title":"差分包","date":"July 12, 2020","tags":["apk","diff","patch","zip"],"categories":"Android"}}},"pageContext":{"slug":"/android-incremental-update-diff-and-patch/","previous":{"fields":{"slug":"/arouter-autowired-zi-dong-zhu-ru/"},"frontmatter":{"title":"ARouter @Autowired 自动注入"}},"next":{"fields":{"slug":"/flutter-widget-different-from-android-view/"},"frontmatter":{"title":"Android View - Flutter Widget"}}}},"staticQueryHashes":["2841359383"]}