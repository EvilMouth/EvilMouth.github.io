{"componentChunkName":"component---src-templates-blog-post-js","path":"/android-incremental-update-diff-and-patch/","result":{"data":{"site":{"siteMetadata":{"title":"Evil Mouth","author":{"name":"Evil Mouth"}}},"markdownRemark":{"id":"7bd078a7-ba6c-562d-9607-15df54adeec7","excerpt":"调研Android差分包过程记录 前测 目前市场差分方案有 bsdiff - 最常见的差分方案，例如国内应用市场的增量更新 archive-patcher - 谷歌推出的基于bsdiff的优化方案，使差分包更小 apkdiff - Github开源的项目，基于archive-patcher思想 xdelta…","html":"<p>调研Android差分包过程记录</p>\n<!-- More -->\n<h2>前测</h2>\n<p>目前市场差分方案有</p>\n<ul>\n<li>bsdiff - 最常见的差分方案，例如国内应用市场的增量更新</li>\n<li>archive-patcher - 谷歌推出的基于bsdiff的优化方案，使差分包更小</li>\n<li>apkdiff - Github开源的项目，基于archive-patcher思想</li>\n<li>xdelta - 市面使用较少，但比bsdiff性能佳</li>\n</ul>\n<p>以两个大约38M的apk作为例子</p>\n<ul>\n<li>bsdiff：差分包10M</li>\n<li>archive-patcher：得基于两个zlib包，所以得先将两个apk进行zlib压缩（体积可能会变大），但是差分效果佳，差分包400k</li>\n<li>apkdiff：使用lzma压缩，差分包300k，但是会导致合成包md5不一致，也可以先将apk进行zlib后再使用apkdiff，则md5相同</li>\n<li>xdelta：差分包10M，但是差分和合成的速度和内存优于bsdiff</li>\n</ul>\n<h2>分析</h2>\n<h3>bsdiff</h3>\n<ul>\n<li>比较常见的差异算法，不过因为较通用，所以没有考虑apk实际上是一个zip压缩包的情况，直接将apk当成文件去进行差异对比，所以产生的差异包较大</li>\n<li>patch时需要用到O(m+n)的内存</li>\n</ul>\n<h3>archive-patcher</h3>\n<ul>\n<li>严格基于zlib，apk需要使用zlib重新压缩</li>\n<li>差分和合成依旧使用bsdiff</li>\n<li>之所以差分包大小比bsdiff小是因为先解压后再diff，比直接diff更容易描述差异</li>\n<li>如果apk没有zlib，将直接bsdiff（差异包大小会与bsdiff一样大）</li>\n<li>将apk解压后进行file-to-file的差异对比，得到差异包</li>\n<li>patch阶段将差异包压缩回apk（使用了zlib）得到最终apk包</li>\n</ul>\n<h3>apkdiff</h3>\n<ul>\n<li>合成后只保证逻辑相同，不保证二进制相同，这一点可以通过zlib压缩后解决（因为解压和压缩用了相同的编码）</li>\n<li>差分和合成使用hdiff，性能优于bsdiff</li>\n<li>核心原理是将apk解压后进行差异对比，改动越小，差异包越小，比较符合增量更新意义</li>\n<li>比archive-patcher暴力的是diff阶段直接解压然后差异对比，patch阶段直接zlib压缩回apk包，所以会导致二进制不相同</li>\n<li>所以提供了ApkNormalized预处理apk包</li>\n<li>需要注意的是，ApkNormalized重新压缩apk包后导致的二进制不相同会影响v2和v3的签名（v1不影响是v1不严格要求），所以如果项目使用v2或v3的签名方式需要在ApkNormalized后进行重签名</li>\n</ul>\n<h3>xdelta</h3>\n<ul>\n<li>性能比bsdiff好以及稳定，但差异包大小与bsdiff差不多甚至更大一些</li>\n<li>没有继续研究</li>\n</ul>\n<h2>接入成本</h2>\n<ul>\n<li>以armeabi-v7a为例</li>\n<li>jni以so实际大小</li>\n<li>java以jar实际大小</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>bsdiff</th>\n<th>archive-patcher</th>\n<th>apkdiff</th>\n<th>xdelta</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>接入方式</td>\n<td>jni</td>\n<td>java</td>\n<td>jni</td>\n<td>jni</td>\n</tr>\n<tr>\n<td>接入大小</td>\n<td>322KB</td>\n<td>190KB</td>\n<td>137KB</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2>diff对比</h2>\n<ul>\n<li>由于diff过程属于预处理，一般放在服务器，所以只做时间对比</li>\n<li>设备信息如下</li>\n<li>\n<ul>\n<li>macOs Catalina 10.15.4</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>3.1GHz i5 16GB</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>bsdiff</th>\n<th>archive-patcher</th>\n<th>apkdiff</th>\n<th>xdelta</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>差分包生成时间</td>\n<td>42s左右</td>\n<td>24s左右</td>\n<td>10s左右</td>\n<td>4s左右</td>\n</tr>\n</tbody>\n</table>\n<h2>patch对比</h2>\n<ul>\n<li>测试机信息如下</li>\n<li>\n<ul>\n<li>华为LRA-AL00 Android9 API28</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>运行内存 8.0GB</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>屏幕 2400 x 1080</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>手机存储 128 GB</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>CPU架构 arm64-v8a</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>bsdiff</th>\n<th>archive-patcher</th>\n<th>apkdiff</th>\n<th>xdelta</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>差分包大小</td>\n<td>10.6M</td>\n<td>448k</td>\n<td>304k</td>\n<td></td>\n</tr>\n<tr>\n<td>cpu占用</td>\n<td>17%-24%</td>\n<td>17%-22%</td>\n<td>17%-23%</td>\n<td></td>\n</tr>\n<tr>\n<td>内存占用</td>\n<td>86M</td>\n<td>80M</td>\n<td>6M</td>\n<td></td>\n</tr>\n<tr>\n<td>合成时间</td>\n<td>5104ms</td>\n<td>3841ms</td>\n<td>3140ms</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>实际做了挺多次对比，结果大致相同，所以不放出</p>\n</blockquote>\n<h2>patch时多渠道因素</h2>\n<h3>问题</h3>\n<p>前因</p>\n<ul>\n<li>差异包只会打一个，以官方渠道包的新旧两个apk进行差异对比得到的差异包</li>\n<li>线上会存在多种渠道包，目前渠道包以两种形式存在</li>\n<li>1、ng-plugin生成的渠道包（在Zip Comment Central Directory区域实现）</li>\n<li>2、Android Manifest中meta-data（部分渠道包还会更改应用名）</li>\n</ul>\n<p>后果</p>\n<ul>\n<li>由于diff&#x26;patch要求oldApk完全一致（渠道包因为Android Manifest文件不同已经破坏一致），线上用户使用本地渠道包进行patch违反这一条约，所以patch会失败</li>\n</ul>\n<h3>如何解决Zip Comment Central Directory</h3>\n<p>ng-plugin方案是在Central Directory的注释部分插入渠道信息，不会到apk造成破坏，可以正常安装，但注释也是数据的一部分，也会参与diff，所以会造成渠道包和原始包不一致导致无法patch</p>\n<ul>\n<li>通过先抹除渠道信息再patch</li>\n<li>如果需要保留原渠道信息，还可以再进行渠道的插入</li>\n</ul>\n<h3>如何解决Android Manifest</h3>\n<p>思路1</p>\n<ul>\n<li>用户在拿到patch包后</li>\n<li>利用本地渠道包还原oldApk，再以oldApk去进行patch得到newApk</li>\n<li>难点1、还原oldApk过程需要与Jenkins打包流程一致才能保证100%还原</li>\n<li>不足点1、还原所需时间=打包所需时间，用户端消耗不起</li>\n</ul>\n<p>思路2</p>\n<ul>\n<li>diff阶段排除Android Manifest文件的差异对比</li>\n<li>下发patch包同时下发新的Android Manifest文件</li>\n<li>patch阶段将新Android Manifest文件copy进去后再压缩回apk文件</li>\n<li>难点1、保证生成的newApk与正常流程的newApk一致</li>\n</ul>\n<h2>Demo</h2>\n<p><a href=\"https://github.com/izyhang/DiffPatchRecord\">https://github.com/izyhang/DiffPatchRecord</a></p>","frontmatter":{"title":"差分包","date":"July 12, 2020","tags":["apk","diff","patch","zip"],"categories":"Android"}}},"pageContext":{"slug":"/android-incremental-update-diff-and-patch/","previous":{"fields":{"slug":"/arouter-autowired-zi-dong-zhu-ru/"},"frontmatter":{"title":"ARouter @Autowired 自动注入"}},"next":{"fields":{"slug":"/flutter-widget-different-from-android-view/"},"frontmatter":{"title":"Android View - Flutter Widget"}}}},"staticQueryHashes":["2841359383"]}